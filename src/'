#ifndef _Z
	#include "zmain.c"
#endif

#define zMaxEvents 64
#define UDP 0
#define TCP 1

/*
 * return contents from cache directly
 * use zsendmsg
 * msg form(sent from frontend, to git_shadow):
 * [OpsMark(l/d/D/R)][struct zFileDiffInfo]
 * Meaning:
 *		 -l:list modified file list, default behavior
 *		 -d:file content diff
 *		 -D:deploy, need shell script
 *		 -L:list deploy log
 *		 -R:revoke, need shell script
 *		 -r:reply msg from ECS
 */
void
zlist_diff_files(_i zSd, zFileDiffInfo *zpIf){
	zsendmsg(zSd, zppCacheVec[zpIf->RepoId], zpCacheVecSiz[zpIf->RepoId], 0, NULL);
}

void
zprint_diff_contents(_i zSd, zFileDiffInfo *zpIf){
	if (zpIf->CacheVersion == ((zFileDiffInfo *)(zppCacheVec[zpIf->RepoId]->iov_base))->CacheVersion) {
		zsendmsg(zSd, zpIf->p_DiffContent, zpIf->VecSiz, 0, NULL);
	}
	else {
		zsendto(zSd, "!", 2 * sizeof(char), NULL);  // if cache version has changed, return a '!' to frontend
	}
}

#define zPrevLoadLogSiz 10
zDeployLogInfo zPreLoadLogMetaIf[zPrevLoadLogSiz];
char *zpPreLoadLogData;

// 列出最近10次或全部历史布署日志
void
zlist_log(_i zSd, zFileDiffInfo *zpIf, _i zMarkAll) {
	struct stat zStatBuf;
	zCheck_Negative_Exit(fstat(zpLogFd[0][zpIf->RepoId], &(zStatBuf)));  // 获取日志属性

	_i zVecNum = 2 * zStatBuf.st_size / sizeof(zDeployLogInfo);  // 确定存储缓存区的大小
	struct iovec zVec[zVecNum];

	zDeployLogInfo *zpMetaLog = mmap(NULL, zStatBuf.st_size, PROT_READ, MAP_PRIVATE, zpLogFd[0][zpIf->RepoId], 0);  // 将meta日志mmap至内存
	zCheck_Null_Exit(zpMetaLog);
	madvise(zpMetaLog, zStatBuf.st_size, MADV_WILLNEED);  // 提示内核大量预读

	_ul zDataLogSiz = (zpMetaLog + zStatBuf.st_size - sizeof(zDeployLogInfo))->offset + (zpMetaLog + zStatBuf.st_size - sizeof(zDeployLogInfo))->len;  // 根据meta日志属性确认data日志偏移量
	char *zpDataLog = mmap(NULL, zDataLogSiz, PROT_READ, MAP_PRIVATE, zpLogFd[1][zpIf->RepoId], 0);  // 将data日志mmap至内存
	zCheck_Null_Exit(zpDataLog);
	madvise(zpDataLog, zDataLogSiz, MADV_WILLNEED);  // 提示内核大量预读

	for (_i i = 0; i < zVecNum; i++) {  // 拼装日志信息
		if (0 == i % 2) {
			zVec[i].iov_base = zpMetaLog + i / 2;
			zVec[i].iov_len = sizeof(zDeployLogInfo);
		}
		else {
			zVec[i].iov_base = zpDataLog + (zpMetaLog + i / 2)->offset;
			zVec[i].iov_len = (zpMetaLog + i / 2)->len;
		}
	}

	zsendmsg(zSd, zVec, zVecNum, 0, NULL);	// 发送结果

	munmap(zpMetaLog, zStatBuf.st_size);  // 解除mmap
	munmap(zpDataLog, zDataLogSiz);

	for (_i i = 0; i < zPrevLoadLogSiz; i++) {  // 拼装日志信息
		if (0 == i % 2) {
			zVec[i].iov_base = zPreLoadLogMetaIf + i / 2;
			zVec[i].iov_len = sizeof(zDeployLogInfo);
		}
		else {
			zVec[i].iov_base = zpPreLoadLogData+ (zPreLoadLogMetaIf + i / 2)->offset;
			zVec[i].iov_len = (zpMetaLog + i / 2)->len;
		}
	}

	zsendmsg(zSd, zVec, zVecNum, 0, NULL);	// 发送结果

}

void
zmilli_sleep(_i zMilliSec) {  // 毫秒级sleep
	static struct timespec zNanoSecIf = { .tv_sec = 0, };
	zNanoSecIf.tv_nsec  = zMilliSec * 1000000;
	nanosleep(&zNanoSecIf, NULL);
}

// 记录布署或撤销的日志
void
zwrite_log(_i zRepoId, char *zpPathName, _i zPathLen) {
	// write to .git_shadow/log/meta
	struct stat zStatBuf;
	zCheck_Negative_Exit(fstat(zpLogFd[0][zRepoId], &zStatBuf));  // 获取当前日志文件属性

	zDeployLogInfo zDeployIf;
	pread(zpLogFd[0][zRepoId], &zDeployIf, sizeof(zDeployLogInfo), zStatBuf.st_size - sizeof(zDeployLogInfo));  // 读出前一个记录的信息

	zDeployIf.RepoId = zRepoId;  // 代码库ID相同
	zDeployIf.index += 1;  // 布署索引偏移量增加1(即：顺序记录布署批次ID)，用于从sig日志文件中快整定位对应的commit签名
	zDeployIf.offset += zPathLen;  // data日志中对应的文件路径名称位置偏移量
	zDeployIf.TimeStamp = time(NULL);  // 日志时间戳(1900至今的秒数)
	zDeployIf.len = zPathLen;  // 本次布署的文件路径名称长度

	// 其本信息写入.git_shadow/log/meta
	if (sizeof(zDeployLogInfo) != write(zpLogFd[0][zRepoId], &zDeployIf, sizeof(zDeployLogInfo))) {
		zPrint_Err(0, NULL, "Can't write to log/meta!");
		exit(1);
	}
	// 将本次布署的文件路径名称写入.git_shadow/log/data尾部
	if (zPathLen != write(zpLogFd[1][zRepoId], zpPathName, zPathLen)) {
		zPrint_Err(0, NULL, "Can't write to log.data!");
		exit(1);
	}
	// 将本次布署之前的CURRENT标签的40位sig字符串追加写入.git_shadow/log/sig
	if ( 40 != write(zpLogFd[2][zRepoId], zppCurTagSig[zRepoId], 40)) {
		zPrint_Err(0, NULL, "Can't write to log.sig!");
		exit(1);
	}
}

// 执行布署
void
zdeploy(_i zSd, zFileDiffInfo *zpDiffIf, _i zMarkAll) {
	if (zpDiffIf->CacheVersion == ((zFileDiffInfo *)(zppCacheVec[zpDiffIf->RepoId]->iov_base))->CacheVersion) {  // 确认缓存版本是否一致
		char zShellBuf[4096];  // 存放SHELL命令字符串
		char *zpLogContents;   // 布署日志备注信息，默认是文件路径，若是整次提交，标记字符串"ALL"
		_i zLogSiz;
		if (1 == zMarkAll) { 
			sprintf(zShellBuf, "~git/.git_shadow/scripts/zdeploy.sh -D -P %s", zppRepoList[zpDiffIf->RepoId]); 
			zpLogContents = "ALL";
			zLogSiz = 4 * sizeof(char);
		} 
		else { 
			sprintf(zShellBuf, "~git/.git_shadow/scripts/zdeploy.sh -d -P %s %s", zppRepoList[zpDiffIf->RepoId], zpDiffIf->path); 
			zpLogContents = zpDiffIf->path;
			zLogSiz = zpDiffIf->PathLen;
		}

		pthread_mutex_lock(&(zpDeployLock[zpDiffIf->RepoId]));  // 加锁，布署没有完成之前，阻塞相关请求，如：布署、撤销、更新缓存等
		system(zShellBuf);

		_ui zSendBuf[zpRepoClientNum[zpDiffIf->RepoId]];  // 用于存放尚未返回结果(状态为0)的客户端ip列表
		_i i;
		do {
			zmilli_sleep(2000);  // 每隔0.2秒向前端返回一次结果

			for (i = 0; i < zpRepoClientNum[zpDiffIf->RepoId]; i++) {  // 登记尚未确认状态的客户端ip列表
				if (0 == zppDpResList[zpDiffIf->RepoId][i].DeployState) {
					zSendBuf[i] = zppDpResList[zpDiffIf->RepoId][i].ClientAddr;
				}
			}

			zsendto(zSd, zSendBuf, i * sizeof(_ui), NULL);
		} while (zpReplyCnt[zpDiffIf->RepoId] < zpTotalHost[zpDiffIf->RepoId]);  // 等待所有client端确认状态：前端人工标记＋后端自动返回

		zwrite_log(zpDiffIf->RepoId, zpLogContents, zLogSiz);  // 将本次布署信息写入日志

		for (_i i = 0; i < zpRepoClientNum[zpDiffIf->RepoId]; i++) {
			zppDpResList[zpDiffIf->RepoId][i].DeployState = 0;  // 重置client状态，以便下次布署使用
		}

		pthread_mutex_unlock(&(zpDeployLock[zpDiffIf->RepoId]));  // 释放锁
	} 
	else {
		zsendto(zSd, "!", 2 * sizeof(char), NULL);  // 若缓存版本不一致，向前端发送“!”标识，要求刷新页面
	}
}

// 依据布署日志，撤销指定文件或整次提交
void
zrevoke_from_log(_i zSd, zDeployLogInfo *zpLogIf, _i zMarkAll){
	char zPathBuf[zpLogIf->len];  // 存放待撤销的目标文件路径
	char zCommitSigBuf[41];  // 存放40位的git commit签名
	zCommitSigBuf[40] = '\0';

	pread(zpLogFd[1][zpLogIf->RepoId], &zPathBuf, zpLogIf->len, zpLogIf->offset);
	pread(zpLogFd[2][zpLogIf->RepoId], &zCommitSigBuf, 40 * sizeof(char), 40 * sizeof(char) * zpLogIf->index);

	char zShellBuf[zCommonBufSiz];  // 存放SHELL命令字符串
	char *zpLogContents;  // 布署日志备注信息，默认是文件路径，若是整次提交，标记字符串"ALL"
	_i zLogSiz;
	if (1 == zMarkAll) { 
		sprintf(zShellBuf, "~git/.git_shadow/scripts/zdeploy.sh -R -i %s -P %s", zCommitSigBuf, zppRepoList[zpLogIf->RepoId]); 
		zpLogContents = "ALL";
		zLogSiz = 4 * sizeof(char);
	} 
	else { 
		sprintf(zShellBuf, "~git/.git_shadow/scripts/zdeploy.sh -d -i %s -P %s %s", zCommitSigBuf, zppRepoList[zpLogIf->RepoId], zPathBuf); 
		zpLogContents = zPathBuf;
		zLogSiz = zpLogIf->len;
	}

	pthread_mutex_lock(&(zpDeployLock[zpLogIf->RepoId]));  // 撤销没有完成之前，阻塞相关请求，如：布署、撤销、更新缓存等
	system(zShellBuf);

	_ui zSendBuf[zpRepoClientNum[zpLogIf->RepoId]];  // 用于存放尚未返回结果(状态为0)的客户端ip列表
	_i i;
	do {
		zmilli_sleep(2000);  // 每0.2秒统计一次结果，并发往前端

		for (i = 0; i < zpRepoClientNum[zpLogIf->RepoId]; i++) {
			if (0 == zppDpResList[zpLogIf->RepoId][i].DeployState) {
				zSendBuf[i] = zppDpResList[zpLogIf->RepoId][i].ClientAddr;
			}
		}

		zsendto(zSd, zSendBuf, i * sizeof(_ui), NULL);  // 向前端发送当前未成功的列表
	} while (zpReplyCnt[zpLogIf->RepoId] < zpTotalHost[zpLogIf->RepoId]);  // 一直等待到所有client状态确认为止：前端人工确认＋后端自动确认

	zwrite_log(zpLogIf->RepoId, zpLogContents, zLogSiz);  // 撤销完成，写入日志

	for (_i i = 0; i < zpRepoClientNum[zpLogIf->RepoId]; i++) {
		zppDpResList[zpLogIf->RepoId][i].DeployState = 0;  // 将本项目各主机状态重置为0
	}

	pthread_mutex_unlock(&(zpDeployLock[zpLogIf->RepoId]));
}

void
zconfirm_deploy_state(zDeployResInfo *zpDpResIf) {
	zDeployResInfo *zpTmp = zpppDpResHash[zpDpResIf->RepoId][zpDpResIf->ClientAddr % zDeployHashSiz];  // HASH定位
	while (zpTmp != NULL) {  // 单点遍历
		if (zpTmp->ClientAddr == zpDpResIf->ClientAddr) {
			zpTmp->DeployState = 1;
			zpReplyCnt[((zDeployResInfo *)(zpDpResIf+ 1))->RepoId]++;
			return;
		}
		zpTmp = zpTmp->p_next;
	}
	zPrint_Err(0, NULL, "Unknown client reply!!!");
}

void
zdo_serv(void *zpSd) {
	_i zSd = *((_i *)zpSd);

	char zReqBuf[zCommonBufSiz];
	zrecv_all(zSd, zReqBuf, zCommonBufSiz, NULL);  // 接收前端指令信息

	switch (zReqBuf[0]) {
		case 'p':  // list:列出内容有变动的文件路径
			zlist_diff_files(zSd, (zFileDiffInfo *)(zReqBuf + 1));
			break;
		case 'P':  // print:打印某个文件的详细变动内容
			zprint_diff_contents(zSd, (zFileDiffInfo *)(zReqBuf + 1));
			break;
		case 'd':  // deploy:布署单个文件
			zdeploy(zSd, (zFileDiffInfo *)(zReqBuf + 1), 0);
			break;
		case 'D':  // DEPLOY:布署当前提交所有文件
			zdeploy(zSd, (zFileDiffInfo *)(zReqBuf + 1), 1);
			break;
		case 'l':  // LIST:打印最近10次布署日志
			zlist_log(zSd, (zFileDiffInfo *)(zReqBuf + 1), 0);
			break;
		case 'L':  // LIST:打印所有历史布署日志
			zlist_log(zSd, (zFileDiffInfo *)(zReqBuf + 1), 1);
			break;
		case 'r':  // revoke:撤销单个文件的更改
			zrevoke_from_log(zSd, (zDeployLogInfo *)(zReqBuf + 1), 0);
			break;
		case 'R':  // REVOKE:撤销某次提交的全部更改
			zrevoke_from_log(zSd, (zDeployLogInfo *)(zReqBuf + 1), 1);
			break;
		case 'c':  // confirm:客户端回复的布署成功确认信息
			zconfirm_deploy_state((zDeployResInfo *)(zReqBuf + 1));
			break;
		default:
			zPrint_Err(0, NULL, "Undefined request");
	}
}

// exec on server
void
zstart_server(char *zpHost, char *zpPort, _i zServType) {
	struct epoll_event zEv, zEvents[zMaxEvents];
	_i zMajorSd, zConnSd, zEvNum, zEpollSd;

	zMajorSd = zgenerate_serv_SD(zpHost, zpPort, zServType);  // 已经做完bind和listen

	zEpollSd = epoll_create1(0);
	zCheck_Negative_Exit(zEpollSd);

	zEv.events = EPOLLIN;
	zEv.data.fd = zMajorSd;
	zCheck_Negative_Exit(epoll_ctl(zEpollSd, EPOLL_CTL_ADD, zMajorSd, &zEv));

	for (;;) {
		zEvNum = epoll_wait(zEpollSd, zEvents, zMaxEvents, -1);  // 阻塞等待事件发生
		zCheck_Negative_Exit(zEvNum);

		for (_i i = 0; i < zEvNum; i++) {
		   if (zEvents[i].data.fd == zMajorSd) {  // 主socket上收到事件，执行accept
			   zConnSd = accept(zMajorSd, (struct sockaddr *) NULL, 0);
			   zCheck_Negative_Exit(zConnSd);

			   zEv.events = EPOLLIN | EPOLLET;  // 新创建的socket以边缘触发模式监控
			   zEv.data.fd = zConnSd;
			   zCheck_Negative_Exit(epoll_ctl(zEpollSd, EPOLL_CTL_ADD, zConnSd, &zEv));
			}
			else {
				zAdd_To_Thread_Pool(zdo_serv, &(zEvents[i].data.fd));
			}
		}
	}
}

// 在客户端上执行
void
zclient_reply(char *zpHost, char *zpPort) {
	zDeployResInfo zDpResIf;
	_i zFd, zSd, zResLen;
	struct iovec zVec[2];
	char zActionMark = 'c';  // confirm:标识这是一条状态确认信息
	zVec[0].iov_base = &zActionMark;
	zVec[0].iov_len = sizeof(char);
	zVec[1].iov_base = &zDpResIf;
	zVec[1].iov_len = sizeof(zDeployResInfo);

	zFd = open(".git_shadow/log/deploy/meta", O_RDONLY);
	zCheck_Negative_Exit(zFd);

	zDeployLogInfo zDpLogIf;
	zCheck_Negative_Exit(read(zFd, &zDpLogIf, sizeof(zDeployLogInfo)));
	zDpResIf.RepoId = zDpLogIf.RepoId;  // 标识版本库ID
	close(zFd);

	zSd = ztcp_connect(zpHost, zpPort, AI_NUMERICHOST | AI_NUMERICSERV);  // 以点分格式的ipv4地址连接服务端
	if (-1 == zSd) {
		zPrint_Err(0, NULL, "Connect to server failed.");
		exit(1);
	}

	zFd = open(".git_shadow/info/client/host_ip_me.bin", O_RDONLY);  // 读取本机的所有非回环ip地地，依次发送状态确认信息至服务端
	zCheck_Negative_Exit(zFd);

	_ui zIpv4Bin;
	while (0 != (zResLen = read(zFd, &zIpv4Bin, sizeof(_ui)))) {
		zCheck_Negative_Exit(zResLen);
		zDpResIf.ClientAddr = zIpv4Bin;  // 标识本机身份：ipv4地址
		if ((sizeof(char) + sizeof(zDeployLogInfo)) != zsendmsg(zSd, zVec, 2, 0, NULL)) {
			zPrint_Err(0, NULL, "Reply to server failed.");
			exit(1);
		}
	}

	close(zFd);
	shutdown(zSd, SHUT_RDWR);
}

#undef zMaxEvents
#undef UDP
#undef TCP
