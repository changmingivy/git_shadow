#!/usr/bin/env bash

export PATH="/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin"
export HOME=`cat /etc/passwd | grep "^\`whoami\`:" | awk -F: '{print $6}'`

# [ DEBUG ]
printf "\n\n[`date '+%F %H:%M:%S'`]" >> /tmp/.____post-deploy.log 2>&1

# 由于 git push 会一直等待该 hook 执行完毕才会返回，因此放在后台子进程中执行，以缩短两端连接的时间
# git push 完成之后传给 post-update 的参数数量与同批次推送的分支数量相同，
# 参数格式类似：refs/heads/s refs/heads/S

# [ 错误类型 ]
# err4 :目标端磁盘容量不足
# err5 :目标端权限不足
# err6 :目标端文件冲突
# err7 :目标端路径不存在

(
    zPathOnHost=`dirname \`pwd\``

    # 传输过程中IPv6 地址中的冒号以 '_' 进行了替换，此处需要还原
    zMasterAddr=`echo $1 | awk -F@ '{print $2}' | sed 's/_/:/g'`
    zMasterPort=`echo $1 | awk -F@ '{print $3}'`

    zProjId=`echo $1 | awk -F@ '{print $4}'`

    # 传输过程中IPv6 地址中的冒号以 '_' 进行了替换，此处需要还原
    zSelfIpStrAddr=`echo $1 | awk -F@ '{print $5}' | sed 's/_/:/g'`

    # 本次布署的唯一身份标识
    zTimeStamp=`echo $1 | awk -F@ '{print $6}'`
    zDpingSig=`echo $1 | awk -F@ '{print $7}'`

    # 若用户想指定不同于项目创建时的运行路径，可使用此 alias 路径
    zProjAliasPath=`echo $1 | awk -F@ '{print $8}'`
    zProjOnLinePath="`dirname \`dirname \\\`dirname ${zPathOnHost}\\\`\``/`basename ${zPathOnHost}`"

    # 当次布署的活动分支，仅用于所有动作完成后，进行清理
    zServBranch="s@${zMasterAddr}@${zMasterPort}@${zProjId}@${zSelfIpStrAddr}@${zTimeStamp}@${zDpingSig}@${zProjAliasPath}"
    zShadowBranch="S@${zMasterAddr}@${zMasterPort}@${zProjId}@${zSelfIpStrAddr}@${zTimeStamp}@${zDpingSig}@${zProjAliasPath}"

    # 临时保存错误信息的位置
    zErrLogPath="/tmp/.${zProjId}_${zTimeStamp}_errlog"

    # 预置为空
    zOldMasterSig=
    zRecvContent=

    # 当前 hook 执行过程中要去掉执行权限，防止以下的 git 操作触发 hook 无限循环
    chmod 0444 ${zPathOnHost}/.git/hooks/post-update


    # 'SN': 阶段性成功上报
    # 'EN': 错误信息上报
    zTcpReply() {
        # 目标机自请布署的场景，其 zTimeStamp 会被置为 -1，不会回复任何消息
        if [[ 0 -lt ${zTimeStamp} ]]; then
            exec 4<>/dev/tcp/${zMasterAddr}/${zMasterPort}
            printf "{\"OpsId\":${1},\"ProjId\":${zProjId},\"HostAddr\":\"${zSelfIpStrAddr}\",\"RevSig\":\"${2}\",\"TimeStamp\":${zTimeStamp},\"ReplyType\":\"${3}\",\"content\":\"${4}\"}">&4
            zRecvContent=`cat<&4`
            exec 4<&-
            exec 4>&-
        fi
    }

    # 任何一环节失败，将调用此函数处理错误并回撤至原先的版本
    zExitClean() {
        # 尝试回撤至原始版本
        # 此处只能尽力而为，无法进入项目路径，也无进一步措施可用
        cd $zPathOnHost
        if [[ 0 -eq $? ]]; then
            export GIT_DIR="${zPathOnHost}/.git"
            git stash
            git stash clear
            git branch master
            git checkout master
            git reset -q --hard $zOldMasterSig
        fi

        # 处理掉错误日志可能存在会与服务端 SQL 日志冲突的字符
        sed -i 's/[[:blank:]]\+/ /g' ${zErrLogPath}
        sed -i "s/\'/|/g" ${zErrLogPath}
        sed -i 's/"/|/g' ${zErrLogPath}
        sed -i "s/\n/;/g" ${zErrLogPath}

        # 反馈错误信息至服务端
        zTcpReply 8 ${zDpingSig} $1 $2 >> /tmp/.____post-deploy.log 2>&1

        # 删除错误日志文件与自身 pid 文件
        rm ${zErrLogPath} /tmp/.${zProjId}_pid_post-update

        # 清理分支
        git branch -D ${zServBranch}
        git branch -M ${zShadowBranch} "meta@${zMasterAddr}@${zMasterPort}@${zProjId}@${zSelfIpStrAddr}"

        # 退出之前还原权限
        chmod 0755 ${zPathOnHost}/.git/hooks/post-update

        exit 255
    }

    # 首先测试是否可与服务端正常通信
    zTcpReply 0 "" "" ""
    if [[ "!" != ${zRecvContent} ]]; then
        exit 255
    fi

    # 检测必要的路径下是存在权限异常的文件
    mkdir -p ${zProjAliasPath} ${zProjOnLinePath} ${zPathOnHost} ${zPathOnHost}_SHADOW
    chown `whoami` ${zProjAliasPath} ${zProjOnLinePath} ${zPathOnHost} ${zPathOnHost}_SHADOW 2>${zErrLogPath}
    if [[ 0 -ne $? ]]; then
        zExitClean "E5" "`cat ${zErrLogPath}`" >> /tmp/.____post-deploy.log 2>&1
    fi

    # 权限无误，清除可能被创建的空目录
    rmdir ${zProjAliasPath} ${zProjOnLinePath} ${zPathOnHost} ${zPathOnHost}_SHADOW

    ##################
    # 进入项目代码库 #
    ##################
    cd $zPathOnHost 2>${zErrLogPath}
    if [[ 0 -ne $? ]]; then
        zExitClean "E7" "cd $zPathOnHost: `cat ${zErrLogPath}`"\
            >> /tmp/.____post-deploy.log 2>&1
    fi

    # git 环境注册
    export GIT_DIR="${zPathOnHost}/.git"
    git branch master

    # 保留旧的版本号，在布署失败时自动回滚
    zOldMasterSig=`git log master -1 --format=%H`

    # 检测是否存在重复布署动作
    if [[ 0 -ne `\ls /tmp/.${zProjId}_pid_post-update | wc -l` ]]; then
        zOldTimeStamp=`tail -1 /tmp/.${zProjId}_pid_post-update`

        # 同一版本，返回错误
        # 比正在进行的版本更新，kill 之，并清理其创建的分支
        # 比正在进行的版本更老，通常是主机自请布署触发的动作，其时间戳会被置为 -1，此时什么都不需要做
        if [[ ${zTimeStamp} -eq ${zOldTimeStamp} ]]; then
            zExitClean "E8" "duplicate deploy：${zSelfIpStrAddr} `head -2 /tmp/.${zProjId}_pid_post-update | tail -1`"\
                >> /tmp/.____post-deploy.log 2>&1
        elif [[ ${zTimeStamp} -gt ${zOldTimeStamp} ]]; then
            kill -9 `head -1 /tmp/.${zProjId}_pid_post-update`
            git branch -D `head -3 /tmp/.${zProjId}_pid_post-update | tail -1`
            git branch -D `head -4 /tmp/.${zProjId}_pid_post-update | tail -1`
        else
            git branch -D ${zServBranch}
            git branch -M ${zShadowBranch} "meta@${zMasterAddr}@${zMasterPort}@${zProjId}@${zSelfIpStrAddr}"
            chmod 0755 ${zPathOnHost}/.git/hooks/post-update
            exit 0
        fi
    fi

    # 运行期间将自身 Pid、Ip、TimeStamp 等存入文件
    # 用于防止同一项目的多个 post-update 进程并行带来混乱
    # 同时用于清理资源占用
    echo "$$" > /tmp/.${zProjId}_pid_post-update
    echo "${zSelfIpStrAddr}" >> /tmp/.${zProjId}_pid_post-update

    echo "${zServBranch}" >> /tmp/.${zProjId}_pid_post-update
    echo "${zShadowBranch}" >> /tmp/.${zProjId}_pid_post-update

    echo "${zTimeStamp}" >> /tmp/.${zProjId}_pid_post-update

    # 清除可能存在的由于 git 崩溃残留的锁文件
    rm -f ${zPathOnHost}/.git/index.lock
    rm -f ${zPathOnHost}_SHADOW/.git/index.lock

    # 通知服务端已收到代码：上报阶段性成果
    zTcpReply 8 "${zDpingSig}" "S3" "" >> /tmp/.____post-deploy.log 2>&1 &

    # 还原代码到工作区
    git reset -q --hard ${zDpingSig}
    if [[ 0 -ne $? ]]; then
        # \ls -a | grep -vE '^(\.|\.\.|\.git)$' | xargs rm -rf
        git stash
        git stash clear
        git reset -q --hard ${zDpingSig} 2>${zErrLogPath}
        if [[ 0 -ne $? ]]; then
            zExitClean "E6" "git reset(${zPathOnHost}): `cat ${zErrLogPath}`"\
                >> /tmp/.____post-deploy.log 2>&1
        fi
    fi

    # ======== !!!! ========
    # 不再兼容旧版布署创建的项目路径，逐个项目升级时，依次重启相关服务
    # ======== !!!! ========

    # cd ../../`basename ${zPathOnHost}`/.git
    # if [[ 0 -eq $? ]]; then
    #     cd ..
    #     export GIT_DIR="`pwd`/.git"
    #     git branch master
    #     git checkout master
    #     git pull --force ${zPathOnHost}/.git ${zDpingSig}:${zDpingSig}
    #     git reset -q --hard ${zDpingSig}
    # fi

    # 取 master 分支最新版本号，用于校验布署结果
    zMasterSig=`git log master -1 --format=%H`

    # 1、检查两个分支 git log 是否一致
    # 2、检查是否存在文件不一致现象(忽略新产生的未被 git 跟踪的文件)
    if [[ "${zMasterSig}" != "${zDpingSig}" ]]; then
        zExitClean "E6" "code version inconsistent(git log)"\
            >> /tmp/.____post-deploy.log 2>&1
    elif [[ 0 -ne "`git status --short --untracked-files=no | wc -l`" ]]; then
        zExitClean "E6" "work area inconsistent(git status): `pwd`"\
            >> /tmp/.____post-deploy.log 2>&1
    fi

    # 创建项目路径软链接
    # 检测是否有路长冲突，若有，则抛出错误
    if [[ 0 -eq `ls ${zProjOnLinePath} | wc -l` ]]; then
        ln -sT ${zPathOnHost} ${zProjOnLinePath} 2>${zErrLogPath}
        if [[ 0 -ne $? ]]; then
            zExitClean "E6" "`cat ${zErrLogPath}`" >> /tmp/.____post-deploy.log 2>&1
        fi
    elif [[ ('l' != `ls -l ${zProjOnLinePath} | grep -o '^l'`)
        || ((${zPathOnHost} != `readlink -q ${zProjOnLinePath}`) && (`dirname \`dirname ${zPathOnHost}\``/`basename ${zPathOnHost}` != `readlink -q ${zProjOnLinePath}`)) ]]; then
        zExitClean "E6" "路径冲突: ${zProjOnLinePath}" >> /tmp/.____post-deploy.log 2>&1
    fi

    # 若用户指定了 alias 路径，则创建同名软链接指向项目库
    # 检测路径是否有冲突，若有，则抛出错误
    if [[ "" != ${zProjAliasPath} ]]; then
        if [[ 0 -eq `ls ${zProjAliasPath} | wc -l` ]]; then
            ln -sT ${zPathOnHost} ${zProjAliasPath} 2>${zErrLogPath}
            if [[ 0 -ne $? ]]; then
                zExitClean "E6" "`cat ${zErrLogPath}`" >> /tmp/.____post-deploy.log 2>&1
            fi
        elif [[ ('l' != `ls -l ${zProjAliasPath} | grep -o '^l'`)
            || ((${zPathOnHost} != `readlink -q ${zProjAliasPath}`) && (`dirname \`dirname ${zPathOnHost}\``/`basename ${zPathOnHost}` != `readlink -q ${zProjAliasPath}`)) ]]; then
            zExitClean "E6" "路径冲突: ${zProjAliasPath}" >> /tmp/.____post-deploy.log 2>&1
        fi
    fi

    # 通知服务端已确认收到的内容准确无误：布署成功
    zTcpReply 8 ${zMasterSig} "S4" "" >> /tmp/.____post-deploy.log 2>&1 &

    # 布署成功，还原权限
    chmod 0755 ${zPathOnHost}/.git/hooks/post-update

    # 等待确认服务端的全局结果
    # 若全局结果不是成功，则执行回退
    # 全局成功，服务端回复 "S"，失败回复 "F"，尚未确定最终结果回复 "W"
    sleep 10
    while :
    do
        zTcpReply 7 "" "" "" >> /tmp/.____post-deploy.log 2>&1

        if [[ "S" == ${zRecvContent} ]]; then
            break
        elif [[ "F" == ${zRecvContent} ]]; then
            # 尝试回撤至原始版本
            # 此处只能尽力而为，若无法进入项目路径，也无进一步措施可用
            cd $zPathOnHost
            if [[ 0 -eq $? ]]; then
                export GIT_DIR="${zPathOnHost}/.git"
                git stash
                git stash clear
                git branch master
                git checkout master
                git reset -q --hard $zOldMasterSig
            fi

            git branch -D ${zServBranch}
            git branch -M ${zShadowBranch} "meta@${zMasterAddr}@${zMasterPort}@${zProjId}@${zSelfIpStrAddr}"
            exit 255
        else
            # 继续等待
            sleep 5
        fi
    done

    # 删除自身 pid 文件及已用完的分支
    rm /tmp/.${zProjId}_pid_post-update
    git branch -D ${zServBranch}
    git branch -M ${zShadowBranch} "meta@${zMasterAddr}@${zMasterPort}@${zProjId}@${zSelfIpStrAddr}"

    # 清理可能存在的旧版布署系统的遗留文件
    rm -rf ${zProjOnLinePath}_SHADOW

    # git 仓库占用空间超过 200M 时，清理空间
    # 非必须动作，对执行周期要求不严格，故异常退出时，可不必执行此步
    cd ${zPathOnHost}
    if [[ 200 -lt `du -sm .git | grep -o '[0-9]\+'` ]]; then
        git reflog expire --expire=now --all
        git gc --aggressive --prune=all
    fi
) &
